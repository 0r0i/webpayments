<!DOCTYPE html>
<meta charset="utf-8">
<title>Payment Handler Privacy Threat Model</title>
<script src="https://www.w3.org/Tools/respec/respec-w3c" class=
"remove"></script>
<script class='remove'>
var respecConfig = {
  status: "MEMBER-SUB",
  editors: [{
    name: "Danyao Wang",
  }, {
    name: "Ian Jacobs",
  }],
  format: "markdown",
};
</script>

<section id="abstract">
The [Payment Handler API](https://w3c.github.io/payment-handler) is one of several technologies (along with the [Payment Request API](https://w3c.github.io/payment-request)) designed to streamline Web payments and make them more secure.

It is an important design goal that the Payment Handler API not introduce new vulnerabilities that an attacker can exploit to infringe on a user’s privacy. This document describes a threat model for evaluating the design choices of the Payment Handler API against this privacy goal.
</section>

<section id="sotd">
This is a living document that aims to capture an up-to-date view of the privacy threat model to drive discussion of mitigations. It will be updated regularly to match the current state of Payment Request API and Payment Handler API.
</section>

## Terminology

- An [origin](https://html.spec.whatwg.org/multipage/origin.html#concept-origin) is the tuple of a scheme, host, and port that provides the main security boundary on the web. [1]
- A **context** is a set of resources (e.g. websites, applications) that are controlled by the same party or jointly controlled by a set of parties. [1]
- **Tracking** is the collection of data regarding a particular user’s identity or activity across one or more contexts and the retention, use, or sharing of data derived from that activity outside the context in which it occurred. [1]
- A **first party** for a user action is the party that controls the origin of the top-most browsing context or application under which the action happened. [1]
- **Cross-site tracking** is tracking by a third-paty across multiple first-party contexts. [3]
- **Fingerprinting** is using the properties of the user’s behavior and/or computing environment to generate a persistent unique identifier without the need for explicit client-side storage. [3]
- **Super-cookie **is using fingerprinting to recreate state and track users, even after a user has expunged their browsing history and storage.
- A **payment handler** is a web or native application that handles requests for payment. A payment handler can be implemented in different ways:
  - As a Service Worker that implements the Payment Handler API [5]; we call this a “Web-based payment handler”.
  - As a native mobile app that integrates with a browser [6][7].
  - As a built-in capability of a user agent.
- A **merchant** is a website requests payment credentials via, for example, the Payment Request API [8].

## Assumptions

- Users who wish to maintain distinct payment identities on the Web use browser or operating system profiles. For example, if a user does not want a payment handler or other parties to know that two cards (e.g., business and personal) belong to the same individual, the user should make use of two profiles.
- Most browsers are moving in the direction of double-keyed partitioning, whatever the storage mechanism.
- A new user agent capability that allows seamless data sharing across origins will tend to be abused.

## Principles

We use the following principles to help evaluate the quality of design decisions.

**User consent**. Without seeking to precisely define “user consent” in this document, users should have control over the sharing of information. User control may manifest itself in a variety of ways, including:

- The ability to identify the parties they are interacting with;
- Understanding the privacy implications of their choices;
- Deliberate expression of intent to interact and consent to share data. By extension, an origin that the user has not interacted with explicitly should not be able to get data about the user without explicit consent;
- The ability to review and set sensible defaults.
  **Least power**. The protocols should not disclose private details of the user’s' identity or other sensitive information unless required for operational purposes or by legal or jurisdictional rules.

**Minimal friction. **In general, we seek to minimize friction in the user experience. However, “minimal” does not always mean “none,” especially in the pursuit of user privacy and security.

- See also [priority of constituencies](https://dev.w3.org/html5/html-design-principles/#priority-of-constituencies)
  - **No regression**. The payments APIs should provide privacy and security protection that is at least on par with --and in general better than-- existing approaches.

## Scope

### In Scope

This threat model focuses on the following privacy threats that a merchant, a payment handler, or both in collusion, may exploit against a user:

- **Cross-site tracking** enabled by the joining of [user IDs](https://w3cping.github.io/privacy-threat-model/#user-id) from multiple contexts that are not previously known to belong to the same user.
- **Fingerprinting** enabled by the exposure of new properties of a user’s computing environment that can be used as “global static identifiers” [4].
- **Secondary use** [1] enabled by the collection of sensitive information (e.g. address, contact information) without the user’s understanding and deliberate consent or by promiscuous sharing of a user’s activity (e.g., before user commits to a transaction).
- **Unnecessary information sharing**? e.g., the ability to infer user’s demographics or other information (e.g. socioeconomic class) based on availability of credit cards.
  - E.g., The merchant does not need to know all the cards in a user’s wallet in order for that person to complete a payment.

### Out of Scope

- Merchants and payment handlers may prefer to limit data sharing with each other. As long as the data shared does not pertain to the user, the prevention or reduction of such sharing is outside the scope of this document.
- Attacks with the explicit goal to steal identity or money from a user or defraud a merchant are considered security threats. They are discussed separately in the Payment Handler Security Threat Model (TODO).

## Capability Review

The Payment Request API and Payment Handler API (and how they are implemented in Chrome) currently give the following capabilities to merchants and payment handlers.

### Installation

#C1: A merchant can cause a web-based payment handler from a specific origin to be [installed just-in-time](https://github.com/w3c/payment-handler/issues/240) into a user’s browser

- Use case: seamless distribution of handlers for new payment method
- Note: the service worker is only installed (1) upon request.show() followed by (2) user selection of this payment handler for this payment request.
  * #C2: A first-party website can install a service worker without any user gesture or visible UI --an existing capability of [Service Workers](https://www.w3.org/TR/service-workers/#navigator-service-worker-register)-- and register it as a payment handler.
- Use case: allows seamless distribution of payment handlers of new payment methods.

### Communication between origins

. =C3: A merchant can send arbitrary data to an installed payment handler (either web-based or native Android) without any user action or visible UI, via [method-specific data](https://w3c.github.io/payment-request/#dom-paymentmethoddata-data) and request.hasEnrolledInstrument()

- Use case for method-specific data: For some payment methods, a payment handler may need information from the merchant in order to complete the payment. In addition, payment methods may define “capabilities” that the browser can use to determine whether a payment handler is a “match” for the merchant and should be shown to the user.
- Use case for request.hasEnrolledInstrument(): pass payment method specific parameters to a payment handler to determine if the user has enrolled instrument that allows them to complete payment without any friction. Merchant uses this signal to determine whether they should show a particular payment handler’s flow, or fall back to alternatives such as forms.
  * #C4: A merchant can receive arbitrary data from an installed payment handler (either web-based or native Android) after request.show(), either repeatedly via [method-specific details](https://w3c.github.io/payment-request/#dom-paymentmethodchangeevent-methoddetails) or the final PaymentResponse.
- Use case: receive payment method specific details, e.g. credentials that enable a merchant’s payment service provider to complete a payment, or a status code associated with a push payment.

### Merchant knowledge of user environment

. #C5: A merchant can know that payment handlers (corresponding to https://www.w3.org/TR/payment-method-id/#dfn-pmi[payment method identifiers] selected by the merchant) are installed or just-in-time installable in the user’s browser without any user gesture or visible UI, by calling [request.canMakePayment()](https://w3c.github.io/payment-request/#canmakepayment-method).

- Use case: This capability allows a merchant to fall back seamlessly to alternatives (e.g., forms) if the user doesn’t have any payment handler for the payment methods the merchant accepts.
  * #C6: A merchant can check whether the user has at least one enrolled instrument for a given set of payment methods without any user gesture or visible UI, by calling [request.hasEnrolledInstrument()](https://w3c.github.io/payment-request/#hasenrolledinstrument-method). For a web-based payment handler, this triggers a [CanMakePaymentEvent](https://w3c.github.io/payment-handler/#the-canmakepaymentevent) (to be renamed to HasEnrolledInstrumentEvent) in the service worker.
- Use case: allows a merchant to selectively show support for a payment method if and only if the user is highly likely to have a seamless experience (i.e., user has an instrument ready to pay)
- Note: Chrome currently throttles this call to 1 every 30 minutes per merchant origin.
- Note: The corresponding capability is not currently provided for native Android payment handlers.

### Payment Handler browsing context (and its capabilities)

. #C7: Following request.show(), a web-based payment handler can create a [new top-level browsing context](https://w3c.github.io/payment-handler/#dfn-open-window-algorithm) (a.k.a. “payment handler window”), typically presented as a modal overlay over the merchant context, that prevents the user from interacting with the merchant context until the overlay is dismissed.

- Use case: allows payment handler to present an “in-context” user experience for the user to complete the payment. We believe the experience of maintaining the checkout context under the modal window is superior to a redirect.
- See discussion in https://github.com/w3c/payment-handler/issues/351
  * #C8: A payment handler (both web-based and native Android) can complete a payment request without showing any user interface.
- Possible use case: Merchant has a card on file. For a given transaction, merchant seeks a new cryptogram for that card via a payment handler. Because the user has selected the card via the merchant site, the payment handler only needs to communicate with a token service provider (without additional user interaction).
- Use case: not an intentional choice; it’s a consequence of allowing but not mandating that a payment handler should show UI. It may be impossible to mandate for native Android payment apps.
  * #C9: Inside its “payment handler window” a web-based payment handler can access most Web APIs that are available in a top-level context, including storage (e.g. IndexedDB, but not document.cookies), navigating its payment handler window to any origin, embedding iframes, and triggering APIs such as WebAuthn, geolocation, etc.
  _ Use case: allows a payment handler to compose other web experiences, such as a redirect-based OAuth flow inside a payment handler.
  _ Note:
  _ Some functionalities are limited: e.g. window.open is ignored.
  _ There is also a proposal in https://github.com/w3c/payment-handler/issues/351 to limit storage access of both the service worker and the payment handler window to 3P by default, with browser discretion to grant 1P access to the payment handler window up launching if the user has previously granted consent to this payment handler.

## Attack Analysis

### Cross Site Tracking

#### Web-based payment handler as a zero-click tracker

. badph.example hosts a badph.js file that does the following:

- Creates a PaymentRequest that specifies badph.example as a supported method
- Adds the full URL, i.e. location.href, to the method-specific data of the request (#C3)
- Calls request.hasEnrolledInstrument()
  * badph.example convinces merchant1.example and merchant2.example to serve badph.js via a &lt;script> tag
  * User visits badph.example, which installs its service worker and registers it as a payment handler (#C2)
- The service worker records a user ID in IndexedDB
  * User visits merchant1.example. The code from badph.js runs, and request.hasEnrolledInstrument() causes a CanMakePaymentEvent to be triggered in badph.example’s service worker (#C5)
  * The service worker extracts the full URL from CanMakePaymentEvent.methodData (#C3), and sends that and the user ID from IndexedDB (#C9) to badph.example server.
  * Similarly, when a user visits merchant2.example, badph.example can reidentify the same user.

Failure points:

. merchant1.example is able to send data to a third party, badph.example, without a clear intention for the user to interact with badph.example. **#OpaqueDataTransfer**
. badph.example’s service worker is able to access its global storage without receiving clear user consent to interact. **#1PStorageAccess**
. A user cannot be reasonably expected to know that their visit to badph.example enables badph.example to record their history across colluding websites, which can be a large set. badph.example can be masquerade itself behind other useful utility that a merchant may want to include: e.g. socialnetwork.example, usefullibrary.example. **#SilentPersistentStorage**
. Payment Request API is used when no clear payment intention is established. **#NonPaymentUsage**

Mitigations:

- Chrome already implements the following limits on hasEnrolledInstrument():
  - CanMakePaymentEvent is not triggered in incognito mode
  - hasEnrolledInstrument() is throttled to 1 call per 30 minutes per merchant origin
    \*\*\* But this breaks a legitimate use case: a merchant wants to show payment buttons from two legitimate payment methods side-by-side.
  - Chrome setting that allows user to opt-into short-circuiting hasEnrolledInstrument() for all payment handlers
- Require user to opt-in for each payment handler that wants to respond to hasEnrolledInstrument() as part of explicit payment handler installation experience
  - This should eliminate most non-payment websites from being able to exploit Payment Request API.
  - Still won’t be able to prevent real payment handlers to track user’s browsing history on shopping websites.
- Remove hasEnrolledInstrument()
  - Breaks legitimate use case of showing payment buttons. The fundamental tension is that the data passed between merchant and payment handler is not standardized (and may be hard to) and is opaque to the browser, so it is very difficult for the browser to determine which calls are only passing legitimate data and which ones are sneaking in tracking data.
- Service worker can only access 3P storage before request.show(), which requires a user gesture which may serve as an intent to interact
  - Breaks legitimate use case of showing payment buttons because hasEnrolledInstrument() no longer has access to a user ID that it can use to check instrument availability.
- Per-method quota
  - See Fingerprint attack
- Prompt user on hasEnrolledInstrument, e.g. “merchant.example wants to check if you can pay with ph.example: Allow Once, Disallow, Always Allow on merchant.example, Always Disallow on merchant.example”
  - Very intrusive. May discourage the use of hasEnrolledInstrument() [which may not be a bad thing]
- Browser uses telemetry to detect origins that call hasEnrolledInstrument() but never call request.show() and black list known bad behaviors
  - Caveat: easy to blacklist merchant\*.example but harder to blacklist badph.example because telemetry records main resource origin, not subresource origin.

#### Native Android app based payment handler as a zero-click tracker

Same steps as [web-based payment handler as a zero-click track attack](#6-1-1-web-based-payment-handler-as-a-zero-click-tracker), except:

. User installs an Android app published by badph.example (possibly masquerading as a useful tool, a game, etc.)
. The hasEnrolledInstrument() call triggers an IS_READY_TO_PAY intent to badph.example’s Android app.
. The Android app links the full URL and user identity within the app, and either saves it locally or sends to badph.example server.

Failure points:

. A locally installed Android app acts as its own global storage across contexts **#NativeAppAs1PStorage**
. A user cannot be reasonably expected to know that any Android app can be a tracker of their web browsing activities. **#SilentPersistentStorage**

Mitigations:

- Require explicit user opt-in for native Android app to act as payment handler in browser
  - This should eliminate most non-payment apps from being able to exploit Payment Request API
  - Remaining gap: payment apps can still track users across shopping websites.

#### One-click tracking by payment handler

The steps below illustrate the attack assuming a web-based payment handler. The same attack can be performed by a native Android app-based payment handler:

. badph.example hosts a badph.js file that does the following:

- Creates a PaymentRequest that specifies badph.example as a supported method
- Adds the full URL, i.e. location.href, to the method-specific data of the request (#C3)
- Creates a button that calls request.show() when clicked
  * badph.example convinces merchant1.example and merchant2.example to serve badph.js via a &lt;script> tag
  * User visits merchant1.example and clicks on the button created by badph.js. This triggers request.show() which triggers the following:
- A web-based payment handler from badph.example to be installed (#C1)
- A [PaymentRequestEvent](https://w3c.github.io/payment-handler/#the-paymentrequestevent) to be triggered in badph.example’s service worker
  * The service worker reads a user ID from IndexedDB (#C9), or writes a new one if there isn’t already one.
  * The service worker extracts the full URL from PaymentRequestEvent.methodData (#C3), and sends that and the user ID to badph.example server.
  * User visits merchant2.example and click on the badph.js button again.
- badph.example service worker reads user ID from IndexedDB (#C9), identifies the user, and records the new merchant2.example URL in this user’s profile.

This attack is less dangerous than [web-based payment handler as a zero-click track attack](#6-1-1-web-based-payment-handler-as-a-zero-click-tracker) because it requires tricking the user to click on something. On the other hand, request.show() is not subject to throttling like hasEnrolledInstrument().

Failure points:

- The click target may not reveal anything related to badph.example. **#NonPaymentUsage**
- A user cannot be reasonably expected to know that a simple click can enable tracking by a third party, especially that no UI from badph.example is ever shown to the user. **#SilentPersistentStorage**
- The service worker has access to 1P storage without a user’s clear intent to interact. **#1PStorageAccess**

Mitigations:

- **Storage access mitigation: **only grant 1P storage access to payment handler service worker after running the [openWindow algorithm](https://github.com/w3c/payment-handler/issues/351#issuecomment-566642121), which implicitly requests [Storage Access](https://developer.mozilla.org/en-US/docs/Web/API/Storage_Access_API):
  - This increases the likelihood of user suspicion: user clicks on something and a window pops up. If browsers do a good job explaining what this UI is meant for (e.g. by add a “What is this?” info to the UI), and potentially offer the user an option to report surprises, then it should disincentivize the use of this attack.
- Insert browser UI to ask the user, “Do you want to proceed to pay with ph.example?” with option to “Don’t ask me again for ph.example”

#### One-click tracking by web-based payment handler under Storage Access Mitigation

. Same steps 1-3 as [one-click tracking by web-based payment handler](#6-1-3-one-click-tracking-by-payment-handler)

- Because of the storage access mitigation, badph.example’s service worker only has access to 3P storage at this point.
  * badph.example’s service worker calls paymentrequestevent.openWindow() (#C7) to request 1P access. Browser has the discretion to grant this without explicit prompting, depending on prior settings (e.g. user did not opt-out of “stay signed in” when badph.example’s payment handler was installed).
  * badph.example’s service worker looks up user’s 1P ID from IndexedDB (#C9) and links it to data sent by badph.js, e.g. full URL of the current merchant1.example page user is visiting.
  * badph.example’s service worker quickly closes the payment handler window. So the user only sees a flash.
  * User visits merchant2.example and sees a quick flash because badph.example uses the same technique to gain access to 1P storage and records user’s merchant2.example full URL.

Failure points:

- badph.example’s service worker is able to close a payment handler window without user interaction. This is against the purpose of the payment handler window which is to offer user an opportunity to interact. **#(Near)SilentPersistentStorage**

Mitigation:

- Require a user interaction before closing a payment handler window.

#### Zero-click joining of stable IDs between merchant and payment handler

. badph.example convinces merchant.example to host a badph.js (see [web-based payment handler as a zero-click track attack](#6-1-1-web-based-payment-handler-as-a-zero-click-tracker) above).
. User visits merchant.example, which runs badph.js that:
. Inserts user’s ID in merchant.example domain to method-specific data (#C3)
. Transfers it to badph.example’s service worker via request.hasEnrolledInstrument()
. badph.example’s service worker reads badph.example ID for the user from IndexedDB (#C9), and sends that and the merchant.example domain ID to badph.example server.
. A party with access to the server logs of both merchant.example and badph.example can link the two sets of activities together.

This attack is a minor variation of [web-based payment handler as a zero-click track attack](#6-1-1-web-based-payment-handler-as-a-zero-click-tracker) and is less severe because it requires that the attacker to also have access to the server logs of both badph.example and merchant.example. The same mitigation strategies from before are also effective.

### Secondary Use

#### Zero-click collection of user activity by legitimate payment handlers

. Legitimate digital wallet provider, wallet.example, integrates with merchant.example, which sources a wallet.js from wallet.example.
. merchant.example enables one-click purchases via wallet.js as follows:

- wallet.js creates a PaymentRequest with no information about the product or total payment amounts (assuming merchant.example and wallet.example both follow best practices)
- wallet.js calls request.hasEnrolledInstrument() to determine if the user is able to complete a seamless transaction.
- If hasEnrolledInstrument() returns true, wallet.js renders a “Buy now with wallet.example” button.
  * When the user browses to a product page on merchant.example:
- wallet.example’s service worker receives the CanMakePaymentEvent triggered by hasEnrolledInstrument()
  ... It learns that user is browsing merchant.example origin (though it doesn’t have access to the full URL)
  ... It extracts merchant.example origin from [CanMakePaymentEvent.topOrigin](https://w3c.github.io/payment-handler/#the-canmakepaymentevent) and sends it to wallet.example’s backend to determine if this is a legitimate merchant that it should support.
- User decides to not proceed with the purchase. Nevertheless, wallet.example knows that the user considered something on merchant.example.

The same attack can be performed by a native Android app based payment handler.

Failure points:

- merchant.example origin is shared with wallet.example in CanMakePaymentEvent **#OpaqueDataTransfer**
  - However, this is required for origin-based merchant validation

Mitigations:

- Reduce the amount of data that is shared with the payment handler.

#### One-click collection of detailed user information without UI

The steps below assumes a web-based payment handler, but the same attack can be performed by a native Android app based payment handler.

. A user creates an account with wallet.example and enters personal information.
. merchant.example accepts a payment method for which wallet.example can be used.
. User visits merchant.example and clicks on “get a quote”, which in fact creates a PaymentRequest:

- merchant.example [requests shipping and contact information](https://w3c.github.io/payment-request/#dom-paymentoptions)
- merchant.example calls request.show()
  * If “skip-the-sheet” conditions are met (i.e. only one URL-based payment method is requested and a payment handler is already installed), wallet.example’s service worker receives PaymentRequestEvent:
- The service worker looks up user ID from IndexedDB and fetches user information from wallet.example’s backend, e.g. name, address, etc.
  * wallet.example’s service worker sends user information back to merchant.example via PaymentHandlerResponse (#C4) without opening a payment handler window (#C8)
- This step can also be accomplished by the service worker sending data back via PaymentMethodChangeEvent (#C4)
  * merchant.example completes the payment using user’s payment information.

Failure points:

- A user cannot be reasonably expected to know that a single click can enable wallet.example to send sensitive information to merchant.example as there may not be any visible indication that wallet.example is involved at all. **#InvisibleTransaction**

Mitigation:

- Insert browser UI upon request.show() to ask “Do you want to proceed to pay with wallet.example?” with option to “Don’t ask in the future for wallet.example”
  - This works for both web-based and native Android app based payment handlers.
- Require a user interaction inside of a payment handler window before returning data (e.g. via PaymentMethodChangeEvent or PaymentHandlerResponse). Reject the request otherwise.
  - This doesn’t work for native Android app based payment handlers because the browser cannot mandate UI by a native app.

### Fingerprinting

#### Zero-click collection of of payment method / instrument support as fingerprinting bits

. merchant.example iterates over each known payment method and method-specific instrument filter. For each configuration, creates a PaymentRequest and calls request.hasEnrolledInstrument().
. merchant.example builds a bitvector using results from the previous step and use it as additional signals to fingerprint the user.

The effectiveness of this attack to uniquely identify a user depends on three factors:

- The number of bits that can be collected, which is a function of the existing payment methods and filter configurations (e.g. filter by credit card networks)
- The speed of collection, which depends on browser’s throttling of hasEnrolledInstrument() calls.
- The population size of PaymentRequest users: fewer users means a given bitvector is more uniquely identifying.

At the time of writing, the total number of configurations that exists today is C = M \* N + P, where:

- M = # of payment methods backed by credit cards = 3 (i.e. basic-card, https://google.com/pay, https://apple.com/apple-pay)
- N = # of credit card networks ~= 8 ([list](https://source.chromium.org/chromium/chromium/src/+/master:components/payments/core/payment_request_data_util.cc;l=100-102))
- P = # of non-credit-card backed payment methods ~= 0

This gives a rough estimate of C = 24, i.e. merchant.example can build a 24-bit vector to fingerprint the user, as an upper bound. The actual information should be less because:

- Some bits are correlated: e.g. basic-card and https://apple.com/apple-pay bits are mutually exclusive due to browser support. So M in practice is likely 2
- The credit card network bits probably correlate strongly with country, so actual unique networks per country is probably N ~= 3-4 (e.g. visa, mastercard, amex, discover)

So a more realistic estimate may be C = 8 bits of actual information. C will also grow as more payment methods become available (e.g. src, other URL-based payment methods), i.e. increasing P value.

#### Identifying power as a function of population size and C

The table below is a model of the “identifying power” of this fingerprinting vector, measured by the number of uses per bucket, as a function of C and Payment Request API user population size (P):

|=========================================
| 3+| Payment Request API Unique Users (P)
| | P = 100K | P = 1M | P = 100M
| C = 8 (today) | 400 | 4000 | 400K
| C = 9 (e.g. +1 new payment mehtod) | 200 | 2000 | 200K
| C = 10 | 100 | 1000 | 100K
| C = 11 | 50 | 500 | 50K
|=========================================

This means that today, when Payment Request API is not yet widely used, with C = 8, hasEnrolledInstrument() can narrow users down to 400-person buckets. This may be small enough to be worrisome.

#### Effect of throttling

Chrome throttles hasEnrolledInstrument() to 1 call every 30 minutes per merchant origin. This makes the attack not very useful for websites that a user only visits occasionally because they wouldn’t be able to build up a full bitvector without reasonable amount time.

Time required to build a full bitvector:

- If the user stays on a website: 128 hours = 5 days
- If the user visits a website for 1 hour/day: 128 days
- If the user visits a website for 2 hours/day: 64 days

Adding more payment methods will make the bitvector longer, increasing its identifying power for a given population size, but increases the time required to build up the vector.

**Conclusion:** as is, hasEnrolledInstrument() is not a very useful fingerprinting tool.

#### Effect of per-method quota for hasEnrolledInstrument()

The hasEnrolledInstrument() quota creates a problem for merchants: if a legitimate merchant wants to offer a “Buy now with wallet1.example” button side by side with a “Buy now with wallet2.example” button, the quota will cause one of the calls to reject and hence not display the button. A proposed solution is to change the quota to allow 1 call per payment method per 30 minutes per merchant origin. Currently page visibility is not used as part of the time quota, so a user who leaves a tab open in the background is prone to this attack.

With per method quota, the limiting factor for a merchant to collect all the bits is only N, which is \~4 in a given country (because M & P can be computed in parallel). Time required to build a full bitvector of equivalent identifying power as C=8 above:

- If user stays on a website: 4 bits / ( 1 bit / 0.5 hours) \~= 2 hours
- If user visits a website for 1 hour/day: 2 days
- If user visits a website for 2 hours/day: 1 day

A possible attack:

- merchant.example sees a new user (i.e. no merchantUserID in local storage), assigns merchantUserID and starts iterating over the bits
- After 4 days, merchant.example looks up bitvector in their DB and found 400 users with the same bitvector. So merchantUserID is likely one of the 400 users.
- If the user clears their local storage, merchant.example can reidentify the user to within a 400-people group after 4 days.

#### Failure Points

- hasEnrolledInstrument() reveals identifying bits about a user without user gesture or any visible UI.
- The payment handler is able to persist data points across multiple visits. **#SilentPersistentStorage**

#### Mitigations

- Prevent a payment handler from persisting data to storage when it has not been explicitly selected by the user.

## Threat Surface

The attack vectors enumerated above reveal a few common threat surfaces:

. #SilentPersistentStorage

- This refers to the ability of the payment handler to persist data into local or remote storage without explicit user consent to interact with this payment handler, i.e. during hasEnrolledInstrument and canMakePayment.
  * #OpaqueDataTransfer
- This is especially bad when combined with #SilentPersistentStorage or #InvisibleTransaction.
  * #1PStorageAccess
  * #InvisibleTransaction
- This refers to the payment handler’s ability to complete a transaction without explicit user confirmation.
- Adrian: can be a feature. Maybe only bad if coupled with “skip-the-sheet”
  _ Also consider cross-device payment sheet
  _ Risk is lower if user explicitly allowed “no-UI flow” at some point
  * #NativeAppAs1PStorage
- TODO: investigate if native app can push some data to the browser so that browser can use this to answer HEI and CMP w/o sending intent to native app.
  * #NonPaymentUsage
- A successful exploit of this surface requires the merchant to phish a user gesture without revealing to the user that a payment request is triggered.
- See [“explicit cross-origin interaction context” idea](https://docs.google.com/document/d/11N2uAUOU3qOaPkv2HQSjSwiZ31rU0ODllzWu1BBYjts/edit)

### User awareness of hasEnrolledInstrument

The user might consent to hasEnrolledInstrument:

. At registration time.
. When hasEnrolledInstrument called.

In each case, the browser can request user consent for “silent” calls in the future. This might be further refined to be “for this site” or “for all sites.”

Even if the user has consented to allowing hasEnrolledInstrument, the browser may want to make the user aware of potential abuse, for example:

. If the merchant calls hasEnrolledInstrument multiple times within a given time period, the browser can alert the user, and ask the user whether they are ok with this behavior (and want to allow it silently in the future, for this origin or all origins)
. If an embedded origin calls hasEnrolledInstrument within different top-level origins, the browser might inform the user.

### User awareness of payment handler activity with or without windows

Payment handlers can do the following:

. Open no window
. Open a window and close it without user interaction. (How to say this using [transient activation](https://html.spec.whatwg.org/multipage/interaction.html#transient-activation) definition?)
. Open a window and only close it with user interaction

We should harmonize behavior for cases 1 and 2. For example:

. The browser can detect that a payment handler from a given origin is exhibiting behavior 1 or 2.
. Whether or not the payment handler from that origin has ever exhibited behavior 3, the browser does not allow behaviors 1 or 2 without explicit user consent.
. Thus, the browser prompts the user, displaying the origin of the payment handler, a friendly message, and requires confirmation of the behavior or cancel. The browser also offers an option not to be prompted in the future.
. Perhaps there are some contexts (private browsing?) there the browser asks for confirmation in all cases.

### Questions & responses to be organized

**Q: Who can install a payment handler without user interaction?**

A: The origin that hosts a payment handler (e.g. ph.example) can install a service worker and register it as payment handler when a user visits ph.example as a first party. See [#C6](#bookmark=id.rcsxcjsgipg9)

Mitigation:

- Introduce friction at payment handler registration time to mitigate zero- and 1-click concerns named above.

**Q: Can origin X trigger payment handler installation from origin Y without user awareness?**

A: Yes, in the current implementation of Chrome:

- X creates a PaymentRequest that only requests supportedMethod=Y
- Browser just-in-time implementation crawls payment method manifest at Y, and finds a payment handler hosted at Y
- User clicks on something in X, that triggers request.show()
- Y payment handler is now installed [skip the sheet] and can complete the request without showing UI

Mitigation:

- Skip-the-sheet should only work on installed payment handlers, not available to JIT PH.
- Specification note: We should either standardize skip-the-sheet and JIT behavior, or at least provide developer guidance in the specifications.

**Q: How can illegitimate seamlessly-installed payment handlers be filtered out?**

A: It’ll be hard. So current thought is to move away from seamlessly installed payment handlers and rely on user’s brand recognition to filter out most of illegitimate payment handlers. Longer term, we can also imagine using a safe-browsing type approach: filter out any known bad origins, and use telemetry to detect likely bad actors (e.g. high trigger frequency with zero completion rate, never showing UI, etc.)

TODO: Definition of illegitimate PH, possibly based on behavior that falls within the identified scope.

**Q: Are there payment handlers where canmakepayment is always true (and thus**

**should not ping the payment handler)? are there cases where it only**

**depends on the user (not the merchant)? vice-versa?**

A: In Chrome there are currently two cases where the payment handler is not pinged and canmakepayment event returns true:

- User is browsing in incognito mode
- User disables “Allow sites to check if you have payment methods saved” in chrome://settings. The default is enabled, and we don’t currently advertise this setting so most users probably don’t know how to use this.

![images/Payment-Handler0.png image]

Going forward, it may be useful to allow user to configure this per payment handler (perhaps as part of the onboarding process) and make this setting more visible.

**Q: Can there be a distinction made between payment handlers that can share**

**sensitive information (e.g. address) vs those that can't? those that can**

**without user interaction and those that can't?**

A: Possibly. The shipping delegation feature adds ability for payment handler to declare that they handle shipping addresses and/or contact information. But there are two challenges: 1) ultimately all payment information is sensitive 2) a uncooperating payment handler can hide arbitrary data using the method-specific data blob, which is opaque to the browser.

**Q: Does iframe introduce new attack vectors not enumerated?**

TBD

## Next Steps

- Organize mitigations to identity themes / features that should be implemented
- Come up with a list of best practices for PH & merchant developers
- Document assumptions about current state of affairs with data sharing: e.g. how can a user achieve account separation today?

## Mitigation Proposals

### Before request.show(), limit capabilities

- [Read-only storage access before show()](https://docs.google.com/document/d/1novDOVYqgrSjBLKwZX3rUEixQvyxFcfr0O58k6qu6sA/edit#)

### Once payment handler launched, limit capabilities

- window.open(): noop when called from inside a PH window.
  - Should we also print error to DevTool console?
- window.close(): noop when called from inside a PH window: https://crbug.com/1049249
- download attribute of &lt;a> is ignored: https://crbug.com/1046957

## References

* [Target Privacy Threat Model](https://w3cping.github.io/privacy-threat-model)
* [WebKit Tracking Prevention Policy](https://webkit.org/tracking-prevention-policy/)
* [Mozilla Security/Anti tracking policy](https://wiki.mozilla.org/Security/Anti_tracking_policy)
* [A Potential Privacy Model for the Web](https://github.com/michaelkleber/privacy-model)
* [Payment Handler API](https://w3c.github.io/payment-handler/)
* [Android app as a payment handler](https://developers.google.com/web/fundamentals/payments/payment-apps-developer-guide/android-payment-apps)
* [Apple Pay on the Web](https://developer.apple.com/documentation/apple_pay_on_the_web/)
* [Payment Request API](https://w3c.github.io/payment-request/)
* [Who Left Open the Cookie Jar](https://wholeftopenthecookiejar.com/static/tpc-paper.pdf)
